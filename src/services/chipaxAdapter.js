/**
 * ‚úÖ ADAPTADOR CORREGIDO: Sin filtro de "pagadas" 
 * CAMBIO: Mostrar todas las facturas independientemente del estado de pago
 */
export const adaptarCuentasPorPagar = (compras) => {
  if (!Array.isArray(compras)) {
    console.warn('‚ö†Ô∏è adaptarCuentasPorPagar: entrada no es array');
    return [];
  }

  console.log('üí∏ Adaptando compras (SIN FILTRO de pagadas - mostrando todas)...');
  console.log(`üîç INPUT DEBUG: {tipo: '${typeof compras}', esArray: ${Array.isArray(compras)}, longitud: ${compras.length}}`);

  const resultado = compras.map((compra, index) => {
    // Calcular montos
    const montoTotal = parseFloat(compra.montoTotal || compra.monto_total || compra.monto || 0);
    const montoNeto = parseFloat(compra.montoNeto || compra.monto_neto || 0);
    const iva = parseFloat(compra.iva || 0);
    
    // Verificar si est√° anulado
    const estaAnulado = compra.anulado === 'S' || 
                       compra.anulado === true || 
                       compra.estado === 'anulado' ||
                       compra.estado === 'rechazado';
    
    // ‚úÖ CAMBIO PRINCIPAL: NO FILTRAR POR ESTADO DE PAGO
    // Determinar estado sin filtrar pagadas
    let estado = 'Pendiente';
    let saldoPendiente = montoTotal;
    
    if (estaAnulado) {
      estado = 'Anulado';
      saldoPendiente = 0;
    } else {
      // ‚úÖ NUEVO: Determinar estado basado en informaci√≥n disponible
      const fechaPago = compra.fechaPagoInterna || 
                       compra.fecha_pago_interna || 
                       compra.fechaPago || 
                       compra.fecha_pago;
      
      const estadoChipax = compra.estado;
      
      // Mapear estados de Chipax
      if (estadoChipax === 'pagado' || estadoChipax === 'paid') {
        estado = 'Pagado';
        saldoPendiente = 0;
      } else if (estadoChipax === 'aceptado' || estadoChipax === 'accepted') {
        estado = 'Aceptado';
        // ‚úÖ MANTENER MONTO: Aceptado pero no necesariamente pagado
        saldoPendiente = montoTotal;
      } else if (estadoChipax === 'pendiente' || estadoChipax === 'pending') {
        estado = 'Pendiente';
        saldoPendiente = montoTotal;
      } else if (fechaPago) {
        estado = 'Pagado';
        saldoPendiente = 0;
      } else {
        // ‚úÖ DEFAULT: Si no sabemos, asumir pendiente
        estado = 'Pendiente';
        saldoPendiente = montoTotal;
      }
    }
    
    return {
      id: compra.id || index,
      folio: compra.folio || compra.numero || 'S/N',
      razonSocial: compra.razonSocial || compra.razon_social || compra.proveedor || 'Proveedor no especificado',
      rutProveedor: compra.rutEmisor || compra.rut_emisor || compra.rut || 'Sin RUT',
      proveedor: compra.razonSocial || compra.razon_social || compra.proveedor || 'Proveedor no especificado',
      
      // ‚úÖ CAMPOS PRINCIPALES (sin filtrar por pago)
      monto: saldoPendiente,                // Monto seg√∫n estado
      montoTotal: montoTotal,               // Monto original siempre
      montoNeto: montoNeto,
      iva: iva,
      
      // ‚úÖ FECHAS NORMALIZADAS
      fecha: compra.fechaEmision || compra.fecha_emision || compra.fecha || new Date().toISOString().split('T')[0],
      fechaVencimiento: compra.fechaVencimiento || compra.fecha_vencimiento || null,
      fechaPago: compra.fechaPago || compra.fecha_pago || null,
      fechaRecepcion: compra.fechaRecepcion || compra.fecha_recepcion || null,
      
      // ‚úÖ ESTADO Y METADATOS
      estado: estado,
      estadoOriginal: compra.estado,        // Guardar estado original de Chipax
      estaPagado: estado === 'Pagado',
      estaAnulado: estaAnulado,
      
      // Informaci√≥n adicional
      tipo: compra.tipo || compra.tipo_documento || 33,
      tipoCompra: compra.tipoCompra || compra.tipo_compra || 'Del Giro',
      moneda: compra.idMoneda === 1000 || compra.moneda === 'CLP' ? 'CLP' : 'USD',
      descuento: parseFloat(compra.descuento || 0),
      
      // Metadatos √∫tiles
      periodo: compra.periodo || null,
      estadoSII: compra.estado || 'Sin estado',
      eventoReceptor: compra.eventoReceptor || compra.evento_receptor || null,
      
      // Para debugging
      origenDatos: 'compras_sin_filtro_pago',
      fechaProcesamiento: new Date().toISOString()
    };
  });
  
  // üîç DEBUG: Estad√≠sticas detalladas SIN filtrar
  const estadisticas = {
    total: resultado.length,
    pendientes: resultado.filter(c => c.estado === 'Pendiente').length,
    aceptadas: resultado.filter(c => c.estado === 'Aceptado').length,
    pagadas: resultado.filter(c => c.estado === 'Pagado').length,
    anuladas: resultado.filter(c => c.estado === 'Anulado').length,
    montoTotalPendiente: resultado
      .filter(c => c.estado === 'Pendiente' || c.estado === 'Aceptado')
      .reduce((sum, c) => sum + c.monto, 0),
    montoTotalGeneral: resultado.reduce((sum, c) => sum + c.montoTotal, 0)
  };
  
  console.log('üîç DEBUG ADAPTADOR COMPRAS - TODAS LAS FACTURAS:');
  console.log(`  üìã Total compras: ${estadisticas.total}`);
  console.log(`  ‚è≥ Pendientes: ${estadisticas.pendientes}`);
  console.log(`  ‚úÖ Aceptadas: ${estadisticas.aceptadas}`);
  console.log(`  üí≥ Pagadas: ${estadisticas.pagadas}`);
  console.log(`  ‚ùå Anuladas: ${estadisticas.anuladas}`);
  console.log(`  üíµ Monto pendiente+aceptado: ${estadisticas.montoTotalPendiente.toLocaleString('es-CL')}`);
  console.log(`  üí∞ Monto total: ${estadisticas.montoTotalGeneral.toLocaleString('es-CL')}`);
  
  if (resultado.length > 0) {
    const fechaMinima = resultado.reduce((min, c) => c.fecha < min ? c.fecha : min, resultado[0].fecha);
    const fechaMaxima = resultado.reduce((max, c) => c.fecha > max ? c.fecha : max, resultado[0].fecha);
    console.log(`  üìÖ Rango de fechas: ${fechaMinima} ‚Üí ${fechaMaxima}`);
  }
  
  return resultado;
};

/**
 * ‚úÖ FUNCI√ìN OPTIMIZADA: Solo para facturas de 2025 (s√∫per r√°pida)
 */
export const obtenerCompras2025Rapido = async () => {
  console.log('üöÄ Obteniendo SOLO facturas de 2025 (S√öPER R√ÅPIDO)...');

  try {
    let allCompras2025 = [];
    let currentPage = 1;
    let hasMoreData = true;
    const limit = 100; // L√≠mite m√°s alto para ir m√°s r√°pido
    
    // ‚úÖ OPTIMIZACI√ìN: Solo necesitamos pocas p√°ginas para 2025
    const maxPages = 20; // Solo 20 p√°ginas deber√≠an ser suficientes para 2025
    
    console.log(`‚ö° B√∫squeda optimizada para 2025: m√°ximo ${maxPages} p√°ginas`);

    while (hasMoreData && currentPage <= maxPages) {
      try {
        console.log(`üìÑ P√°gina ${currentPage}/${maxPages} (buscando 2025)...`);
        
        // ‚úÖ INTENTAR PAR√ÅMETROS DE FECHA PRIMERO
        let url = `/compras?limit=${limit}&page=${currentPage}`;
        
        // En la primera iteraci√≥n, intentar filtrar por a√±o
        if (currentPage === 1) {
          try {
            console.log('üéØ Intentando filtro directo por a√±o 2025...');
            const testResponse = await fetchFromChipax('/compras?year=2025&limit=100');
            
            if (testResponse && (Array.isArray(testResponse) || testResponse.items || testResponse.data)) {
              let items2025 = [];
              if (Array.isArray(testResponse)) {
                items2025 = testResponse;
              } else if (testResponse.items) {
                items2025 = testResponse.items;
              } else if (testResponse.data) {
                items2025 = testResponse.data;
              }
              
              if (items2025.length > 0) {
                console.log(`üéâ ¬°Filtro por a√±o funciona! ${items2025.length} facturas de 2025 encontradas directamente`);
                return {
                  data: items2025,
                  metodo: 'filtro_directo_2025',
                  pagination: { totalItems: items2025.length, completenessPercent: 100 }
                };
              }
            }
          } catch (error) {
            console.log('‚ö†Ô∏è Filtro por a√±o no disponible, usando m√©todo tradicional...');
          }
        }
        
        const data = await fetchFromChipax(url, { maxRetries: 2, retryDelay: 500 });
        
        let pageItems = [];
        if (Array.isArray(data)) {
          pageItems = data;
        } else if (data.items && Array.isArray(data.items)) {
          pageItems = data.items;
        } else if (data.data && Array.isArray(data.data)) {
          pageItems = data.data;
        }

        if (pageItems.length > 0) {
          // ‚úÖ FILTRAR SOLO 2025 en tiempo real
          const items2025 = pageItems.filter(item => {
            const fechaEmision = item.fechaEmision || item.fecha_emision || item.fecha || '';
            const fechaRecepcion = item.fechaRecepcion || item.fecha_recepcion || '';
            const created = item.created || '';
            
            return fechaEmision.includes('2025') || 
                   fechaRecepcion.includes('2025') || 
                   created.includes('2025');
          });
          
          if (items2025.length > 0) {
            allCompras2025.push(...items2025);
            console.log(`‚úÖ P√°gina ${currentPage}: ${items2025.length} facturas de 2025 (de ${pageItems.length} total)`);
          } else {
            console.log(`üìÑ P√°gina ${currentPage}: Sin facturas de 2025 (${pageItems.length} facturas de otros a√±os)`);
          }
          
          // ‚úÖ Si no encontramos facturas de 2025 en varias p√°ginas consecutivas, parar
          if (items2025.length === 0 && currentPage > 10) {
            console.log('‚ö†Ô∏è Sin facturas de 2025 en √∫ltimas p√°ginas, probablemente no hay m√°s...');
            hasMoreData = false;
          }
          
          if (pageItems.length < limit) {
            hasMoreData = false;
          } else {
            currentPage++;
          }
        } else {
          hasMoreData = false;
        }

        // ‚úÖ PAUSA M√ÅS CORTA para ir m√°s r√°pido
        await new Promise(resolve => setTimeout(resolve, 100));

      } catch (error) {
        console.error(`‚ùå Error en p√°gina ${currentPage}:`, error);
        hasMoreData = false;
      }
    }

    console.log(`üéØ Total facturas de 2025 encontradas: ${allCompras2025.length}`);

    if (allCompras2025.length === 0) {
      console.warn('‚ö†Ô∏è No se encontraron facturas de 2025');
      return { data: [], metodo: 'busqueda_tradicional', pagination: { totalItems: 0 } };
    }

    // ‚úÖ ORDENAR SOLO LAS DE 2025 (mucho m√°s r√°pido)
    console.log('üîÑ Ordenando facturas de 2025 por fecha de recepci√≥n...');
    
    allCompras2025.sort((a, b) => {
      const fechaA = new Date(
        a.fechaRecepcion || a.fecha_recepcion || a.created || 
        a.fechaEmision || a.fecha_emision || a.fecha || '2025-01-01'
      );
      const fechaB = new Date(
        b.fechaRecepcion || b.fecha_recepcion || b.created || 
        b.fechaEmision || b.fecha_emision || b.fecha || '2025-01-01'
      );
      return fechaB - fechaA; // M√°s recientes primero
    });

    // ‚úÖ RESULTADO FINAL
    const facturasMasReciente = allCompras2025[0];
    const fechaReciente = new Date(
      facturasMasReciente.fechaRecepcion || 
      facturasMasReciente.fecha_recepcion || 
      facturasMasReciente.created || 
      facturasMasReciente.fechaEmision
    );
    const hoy = new Date();
    const diasDesdeMasReciente = Math.floor((hoy - fechaReciente) / (1000 * 60 * 60 * 24));

    console.log('\nüéØ RESULTADO FACTURAS 2025:');
    console.log(`üìÖ Factura m√°s reciente: ${fechaReciente.toISOString().split('T')[0]} (hace ${diasDesdeMasReciente} d√≠as)`);
    console.log(`üìã Total facturas 2025: ${allCompras2025.length}`);
    console.log(`üìÑ P√°ginas procesadas: ${currentPage - 1}/${maxPages}`);

    return {
      data: allCompras2025,
      metodo: 'busqueda_tradicional_filtrada',
      pagination: {
        totalItems: allCompras2025.length,
        completenessPercent: 100,
        paginasProc: currentPage - 1
      }
    };

  } catch (error) {
    console.error('‚ùå Error obteniendo facturas 2025:', error);
    return { data: [], error: error.message };
  }
};
